{"version":3,"sources":["Attachment.js","ImBackButton.js","MessageBackButton.js","PostBackButton.js","CardActionButton.js","SuggestedActions.js","util/getValueOrUndefined.js","PlainWebChat.js","App.js","serviceWorker.js","index.js"],"names":["Attachment","_ref","content","contentUrl","contentType","name","react_default","a","createElement","alt","src","href","rel","target","JSON","stringify","connectToWebChat","_ref2","sendMessage","cardAction","onClick","value","type","title","sendMessageBack","text","displayText","sendPostBack","CardActionButton","src_MessageBackButton","src_PostBackButton","src_ImBackButton","suggestedActions","length","map","index","key","getValueOrUndefined","object","_len","arguments","path","Array","_key","shift","apply","concat","_ref6","activities","_useState","useState","_useState2","Object","slicedToArray","sendBoxValue","setSendBoxValue","filter","_ref3","_ref3$channelData","channelData","postBack","from","role","activity","objectSpread","attachments","_ref4","Fragment","id","src_Attachment","textFormat","attachment","src_SuggestedActions","onSubmit","event","preventDefault","autoFocus","onChange","_ref5","_callee","res","token","regenerator_default","wrap","_context","prev","next","fetch","method","sent","json","abrupt","stop","Boolean","window","location","hostname","match","ReactDOM","render","_React$useState","React","_React$useState2","directLine","setDirectLine","getDirectLineToken","then","createDirectLine","lib","Composer","src_PlainWebChat","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.2cb5dcf0.chunk.js","sourcesContent":["import React from \"react\";\n\nconst Attachment = ({ content, contentUrl, contentType, name }) => {\n  switch (contentType) {\n    case \"image/gif\":\n    case \"image/jpeg\":\n    case \"image/png\":\n    case \"image/svg\":\n    case \"image/svg+xml\":\n      return <img alt={name} src={contentUrl} />;\n\n    case \"text/markdown\":\n    case \"text/plain\":\n      return <p>{content}</p>;\n\n    default:\n      if (contentUrl) {\n        return (\n          <a href={contentUrl} rel=\"noopener noreferrer\" target=\"_blank\">\n            {name}\n          </a>\n        );\n      } else {\n        return <pre>{JSON.stringify(content, null, 2)}</pre>;\n      }\n  }\n};\n\nexport default Attachment;\n","import { connectToWebChat } from \"botframework-webchat-component\";\nimport React from \"react\";\n\nconst ImBackButton = ({ cardAction, sendMessage }) => (\n  <button\n    // ImBack is essentially sending a message\n    onClick={() => sendMessage(cardAction.value)}\n    type=\"button\"\n  >\n    ImBack: {cardAction.title}\n  </button>\n);\n\nexport default connectToWebChat(({ sendMessage }) => ({ sendMessage }))(\n  ImBackButton\n);\n","import { connectToWebChat } from \"botframework-webchat-component\";\nimport React from \"react\";\n\nconst MessageBackButton = ({ cardAction, sendMessageBack }) => (\n  <button\n    // Web Chat does the heavylifting for us by exposing a \"sendMessageBack\" function.\n    // We do need to handle \"displayText\" manually in our renderer though.\n    onClick={() =>\n      sendMessageBack(cardAction.value, cardAction.text, cardAction.displayText)\n    }\n    type=\"button\"\n  >\n    MessageBack: {cardAction.title}\n  </button>\n);\n\nexport default connectToWebChat(({ sendMessageBack }) => ({ sendMessageBack }))(\n  MessageBackButton\n);\n","import { connectToWebChat } from \"botframework-webchat-component\";\nimport React from \"react\";\n\nconst PostBackButton = ({ cardAction, sendPostBack }) => (\n  <button\n    // Web Chat does the heavylifting for us by exposing a \"sendPostBack\" function.\n    onClick={() => sendPostBack(cardAction.value)}\n    type=\"button\"\n  >\n    PostBack: {cardAction.title}\n  </button>\n);\n\nexport default connectToWebChat(({ sendPostBack }) => ({ sendPostBack }))(\n  PostBackButton\n);\n","import React from \"react\";\n\nimport ImBackButton from \"./ImBackButton\";\nimport MessageBackButton from \"./MessageBackButton\";\nimport PostBackButton from \"./PostBackButton\";\n\n// \"cardAction\" could be either, \"imBack\", \"messageBack\", or \"postBack\".\nexport default ({ cardAction }) => {\n  switch (cardAction.type) {\n    case \"messageBack\":\n      return <MessageBackButton cardAction={cardAction} />;\n\n    case \"postBack\":\n      return <PostBackButton cardAction={cardAction} />;\n\n    default:\n      return <ImBackButton cardAction={cardAction} />;\n  }\n};\n","import { connectToWebChat } from \"botframework-webchat-component\";\nimport React from \"react\";\n\nimport CardActionButton from \"./CardActionButton\";\n\n// Web Chat cleaned up the suggestedActions for us.\n// If the last activity is from the bot and contains \"suggestedActions\", Web Chat will send it to us thru \"suggestedActions\".\nconst SuggestedActions = ({ suggestedActions }) =>\n  !!suggestedActions.length && (\n    <ul>\n      {suggestedActions.map((cardAction, index) => (\n        <li key={index}>\n          <CardActionButton cardAction={cardAction} />\n        </li>\n      ))}\n    </ul>\n  );\n\nexport default connectToWebChat(({ suggestedActions }) => ({\n  suggestedActions\n}))(SuggestedActions);\n","// This function will follow a path to get a value from an object.\n// If the path leads to \"undefined\", we will return \"undefined\" instead.\nexport default function getValueOrUndefined(object, ...path) {\n  if (typeof object !== \"undefined\" && path.length) {\n    const key = path.shift();\n\n    return getValueOrUndefined(object[key], ...path);\n  } else {\n    return object;\n  }\n}\n","import { connectToWebChat } from \"botframework-webchat-component\";\nimport React, { useState } from \"react\";\n\nimport Attachment from \"./Attachment\";\nimport SuggestedActions from \"./SuggestedActions\";\n\nimport getValueOrUndefined from \"./util/getValueOrUndefined\";\n\nconst PlainWebChat = ({ activities, sendMessage }) => {\n  const [sendBoxValue, setSendBoxValue] = useState(\"\");\n\n  return (\n    <div>\n      <ul>\n        {activities\n          // Currently, this sample only displays an activity of type \"message\"\n          .filter(({ type }) => type === \"message\")\n          // We need to hide \"postBack\" message sent by the user\n          .filter(\n            ({ channelData: { postBack } = {}, from: { role } }) =>\n              !(role === \"user\" && postBack)\n          )\n          // Normalize the activity:\n          // - Every activity should have an \"attachments\" array, consisting of zero or more attachments:\n          // - If this is a \"messageBack\" message, we should use the \"displayText\",\n          //   because \"text\" is being submitted to bot, and \"displayText\" is what we use to override what the bot displays to the user.\n          .map(activity => ({\n            ...activity,\n            attachments: activity.attachments || [],\n            text:\n              getValueOrUndefined(\n                activity,\n                \"channelData\",\n                \"messageBack\",\n                \"displayText\"\n              ) || activity.text\n          }))\n          // Filter out all empty messages (no attachments or text)\n          .filter(({ attachments, text }) => attachments.length || text)\n          .map((activity, index) => (\n            <React.Fragment key={activity.id || index}>\n              <li>\n                {!!activity.text && (\n                  // We are using the very same component for text message and attachments.\n                  // This is because, attachments can also have \"text/markdown\" or \"text/plain\" content.\n                  // In this case, we prefer to have a single component for both of them.\n                  <Attachment\n                    content={activity.text}\n                    contentType={\n                      activity.textFormat === \"markdown\"\n                        ? \"text/markdown\"\n                        : \"text/plain\"\n                    }\n                  />\n                )}\n                {!!activity.attachments.length && (\n                  <ul>\n                    {activity.attachments.map((attachment, index) => (\n                      <li key={index}>\n                        <Attachment {...attachment} />\n                      </li>\n                    ))}\n                  </ul>\n                )}\n              </li>\n            </React.Fragment>\n          ))}\n      </ul>\n      <div>\n        {/* This is the send box, and suggested actions change based on the send box, not activity */}\n        <SuggestedActions />\n        <form\n          onSubmit={event => {\n            event.preventDefault();\n\n            sendMessage(sendBoxValue);\n            setSendBoxValue(\"\");\n          }}\n        >\n          <input\n            autoFocus={true}\n            onChange={({ target: { value } }) => setSendBoxValue(value)}\n            type=\"textbox\"\n            value={sendBoxValue}\n          />\n        </form>\n      </div>\n    </div>\n  );\n};\n\nexport default connectToWebChat(({ activities, sendMessage }) => ({\n  activities,\n  sendMessage\n}))(PlainWebChat);\n","import { Components } from \"botframework-webchat-component\";\nimport { createDirectLine } from \"botframework-webchat\";\nimport React from \"react\";\n\nimport PlainWebChat from \"./PlainWebChat\";\n\n// In this demo, we are using Direct Line token from MockBot.\n// To talk to your bot, you should use the token exchanged using your Direct Line secret.\n// You should never put the Direct Line secret in the browser or client app.\n// https://docs.microsoft.com/en-us/azure/bot-service/rest-api/bot-framework-rest-direct-line-3-0-authentication\n\nasync function getDirectLineToken() {\n  const res = await fetch(\n    \"https://webchat-mockbot.azurewebsites.net/directline/token\",\n    { method: \"POST\" }\n  );\n  const { token } = await res.json();\n\n  return token;\n}\n\nexport default () => {\n  const [directLine, setDirectLine] = React.useState();\n\n  if (!directLine) {\n    // We will load DirectLineJS asynchronously on first render.\n    getDirectLineToken().then(token =>\n      setDirectLine(createDirectLine({ token }))\n    );\n  }\n\n  return (\n    // We are using the \"Composer\" component here, which all descendants will have access to the Web Chat API by HOC-ing thru \"connectToWebChat\".\n    <React.Fragment>\n      <h1>Web Chat with plain UI</h1>\n      <p>\n        This sample shows how to use Web Chat without any of its canned UI\n        component. There are few conversation you can try out.\n      </p>\n      <ol>\n        <li>\n          Say <code>image</code> to the bot\n        </li>\n        <li>\n          Say <code>suggested-actions</code> to the bot\n        </li>\n        <li>\n          Say <code>card bingsports</code> to the bot\n        </li>\n      </ol>\n      <p>\n        For the{\" \"}\n        <a href=\"https://github.com/microsoft/BotFramework-WebChat/tree/master/samples/21.customization-plain-ui/\">\n          source code of this demo\n        </a>\n        , please visit{\" \"}\n        <a href=\"https://github.com/microsoft/BotFramework-WebChat/\">\n          our GitHub repository\n        </a>\n        .\n      </p>\n      <hr />\n      {!!directLine && (\n        <Components.Composer directLine={directLine}>\n          <PlainWebChat />\n        </Components.Composer>\n      )}\n    </React.Fragment>\n  );\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}